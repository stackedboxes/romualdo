/******************************************************************************\
* The Romualdo Language                                                        *
*                                                                              *
* Copyright 2020-2023 Leandro Motta Barros                                     *
* Licensed under the MIT license (see LICENSE.txt for details)                 *
\******************************************************************************/

package vm

import (
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/stackedboxes/romualdo/pkg/bytecode"
	"github.com/stackedboxes/romualdo/pkg/errs"
)

// State represents the state of a VM.
type State int

const (
	// StateNew is the state of a VM that has just been created. From here,
	// you'd typically call VM.Start() or VM.LoadState().
	StateNew State = iota

	// StateWaitingForInput is the state of a VM that has started executing the
	// Storyworld and is waiting for input from the user. The typical next
	// action is to call either VM.Step() or VM.SaveState(). VM.LoadState() is
	// also valid.
	StateWaitingForInput

	// StateEndOfStory is the state of a VM that has finished executing the
	// Storyworld. From here, could simply exit, but calling VM.LoadState() or
	// VM.Start() are also valid. VM.SaveState() is also possible, but a bit
	// odd.
	StateEndOfStory

	// stateRunning is the state of a VM that is executing the Storyworld. Users
	// shall never see a VM on this state (which explains why the constant is
	// not exported), as it's used only internally by the VM. It is used to help
	// detecting internal inconsistencies.
	stateRunning = -1
)

// VM is a Romualdo Virtual Machine.
type VM struct {
	// State is the current state of the VM.
	State State

	// Set DebugTraceExecution to true to make the VM disassemble the code as it
	// runs through it.
	DebugTraceExecution bool

	// Options contains the options available to the Player. It is only valid
	// when VM.WaitingForInput is true.
	Options string

	// outBuffer is where the VM sends its output to during the execution of a
	// step.
	outBuffer strings.Builder

	// csw is the compiled storyworld we are executing.
	csw *bytecode.CompiledStoryworld

	// debugInfo contains the debug information corresponding to csw.
	// TODO: Make this optional. If nil, issue less friendly error messages,
	// etc.
	debugInfo *bytecode.DebugInfo

	// stack is the VM stack, used for storing values during interpretation.
	stack *Stack

	// frames is the stack of call frames. It has one entry for every function
	// that has started running bit hasn't returned yet.
	frames []*callFrame

	// The current call frame (the one on top of VM.frames).
	frame *callFrame
}

// New returns a new Virtual Machine capable of executing the given Storyworld
// csw. If not nil, the VM will use the given DebugInfo di to provide better
// error messages.
func New(csw *bytecode.CompiledStoryworld, di *bytecode.DebugInfo) *VM {
	return &VM{
		stack:     &Stack{},
		csw:       csw,
		debugInfo: di,
	}
}

// Start starts the execution of the Storyworld, running until the first Listen
// instruction or the end of the Story (whatever comes first). Returns the first
// output generated by the Storyworld.
//
// Must be called when vm.Started is false, otherwise it panics.
func (vm *VM) Start() string {
	if vm.State != StateNew {
		panic(errs.NewICE("Called Start() with the VM already started"))
	}
	vm.State = stateRunning

	// Normal Procedure calls start by pushing the callable thing. Here we have
	// an implicit call to the initial Procedure, so we push it. This keeps this
	// implicit call consistent with calls made by the user, and avoid having to
	// treat it as a special case elsewhere.
	vm.push(bytecode.NewValueProcedure(vm.csw.InitialChunk))
	proc := bytecode.Procedure{ChunkIndex: vm.csw.InitialChunk}
	vm.callProcedure(proc, 0)
	vm.frame = vm.frames[0]

	vm.runStep()
	output := vm.outBuffer.String()
	vm.outBuffer.Reset()
	return output
}

// Step executes of the Storyworld until the next Listen instruction or the end
// of the Story (whatever comes first). Returns the output generated by the
// Storyworld.
//
// Must be called when VM.WaitingForInput is true, otherwise it panics.
func (vm *VM) Step(choice string) string {
	if vm.State != StateWaitingForInput {
		panic(errs.NewICE("VM.Step() called while not waiting for input"))
	}

	vm.push(bytecode.NewValueString(choice))
	vm.State = stateRunning

	vm.runStep()
	output := vm.outBuffer.String()
	vm.outBuffer.Reset()
	return output
}

func (vm *VM) SaveState(dst io.Writer) errs.Error {
	return &errs.Runtime{Message: "Not implemented"}
}

func (vm *VM) LoadState(src io.Reader) errs.Error {
	return &errs.Runtime{Message: "Not implemented"}
}

// currentChunk returns the chunk currently being executed.
func (vm *VM) currentChunk() *bytecode.Chunk {
	return vm.csw.Chunks[vm.frame.proc.ChunkIndex]
}

// runStep runs the VM until it reaches either a Listen instruction or the end
// of the story.
func (vm *VM) runStep() {
	for vm.State != StateWaitingForInput && vm.State != StateEndOfStory {
		vm.runInstruction()
	}
}

// runInstruction runs the next instruction.
func (vm *VM) runInstruction() {
	// TODO: Temporary hack to detect the of end of a program. Eventually,
	// this will be done by the return instruction.
	if vm.frame.ip >= len(vm.currentChunk().Code) {
		vm.State = StateEndOfStory
		return
	}

	if vm.DebugTraceExecution {
		fmt.Print("Stack: ")

		for _, v := range vm.stack.data {
			fmt.Printf("[ %v ]", v.DebugString(vm.debugInfo))
		}

		fmt.Print("\n")

		chunkIndex := vm.frame.proc.ChunkIndex
		vm.csw.DisassembleInstruction(vm.currentChunk(), os.Stdout, vm.frame.ip, vm.debugInfo, chunkIndex)
	}

	currentChunk := vm.currentChunk()
	instruction := currentChunk.Code[vm.frame.ip]
	vm.frame.ip++

	switch bytecode.OpCode(instruction) {
	case bytecode.OpNop:
		break

	case bytecode.OpConstant:
		constant := vm.readConstant()
		vm.push(constant)

	case bytecode.OpSay:
		value := vm.pop()
		if !value.IsLecture() {
			vm.runtimeError("Expected a Lecture, got %T", value.Value)
		}
		vm.outBuffer.WriteString(value.AsLecture().Text)

	case bytecode.OpListen:
		vm.State = StateWaitingForInput
		vm.Options = vm.pop().AsString()
		return

	case bytecode.OpTrue:
		vm.push(bytecode.NewValueBool(true))

	case bytecode.OpFalse:
		vm.push(bytecode.NewValueBool(false))

	case bytecode.OpPop:
		vm.pop()

	case bytecode.OpJump:
		// Jump by jumpOffset bytes. The -1 accounts for the fact that the
		// jump offsets are (by design) in relation to the jump instruction
		// address, but at this point the instruction pointer has already
		// advanced one byte beyond the jump instruction.
		jumpOffset := bytecode.DecodeInt32(vm.currentChunk().Code[vm.frame.ip:]) - 1
		vm.frame.ip += jumpOffset

	case bytecode.OpJumpIfFalse:
		// See implementation of OpJump for an explanation on the -1 here.
		jumpOffset := bytecode.DecodeInt32(vm.currentChunk().Code[vm.frame.ip:]) - 1
		condition := vm.pop()
		if condition.IsBool() && !condition.AsBool() {
			// Jump by jumpOffset bytes.
			vm.frame.ip += jumpOffset
		} else {
			// No real jump, just make the IP skip over the 4-byte immediate
			// argument.
			vm.frame.ip += 4
		}

	case bytecode.OpEqual:
		b := vm.pop()
		a := vm.pop()
		vm.push(bytecode.NewValueBool(bytecode.ValuesEqual(a, b)))

	case bytecode.OpNotEqual:
		b := vm.pop()
		a := vm.pop()
		vm.push(bytecode.NewValueBool(!bytecode.ValuesEqual(a, b)))

	case bytecode.OpToString:
		if vm.top().IsString() {
			break
		}
		v := vm.pop()
		s := v.String()
		vm.push(bytecode.NewValueString(s))

	case bytecode.OpToLecture:
		if vm.top().IsLecture() {
			break
		}
		v := vm.pop()
		s := v.String()
		vm.push(bytecode.NewValueLecture(s))

	default:
		vm.runtimeError("Unexpected instruction: %v", instruction)
	}
}

// readConstant reads a 32-bit constant index from the chunk bytecode and
// returns the corresponding constant value.
func (vm *VM) readConstant() bytecode.Value {
	chunk := vm.currentChunk()
	index := bytecode.DecodeUInt31(chunk.Code[vm.frame.ip:])
	constant := vm.csw.Constants[index]
	vm.frame.ip += 4
	return constant
}

// push pushes a value into the VM stack.
func (vm *VM) push(value bytecode.Value) {
	vm.stack.push(value)
}

// top returns the value on the top of the VM stack (without removing it).
// Panics on underflow.
func (vm *VM) top() bytecode.Value {
	return vm.stack.top()
}

// pop pops a value from the VM stack and returns it. Panics on underflow.
func (vm *VM) pop() bytecode.Value {
	return vm.stack.pop()
}

// peek returns a value on the stack that is a given distance from the top.
// Passing 0 means "give me the value on the top of the stack". The stack is not
// changed at all.
func (vm *VM) peek(distance int) bytecode.Value {
	return vm.stack.peek(distance)
}

// callProcedure calls Procedure proc. Assumes that the function and its arguments
// were pushed into the stack. Pushes a new frame into vm.frames.
func (vm *VM) callProcedure(proc bytecode.Procedure, argCount int) {
	vm.frames = append(vm.frames, &callFrame{
		proc:  proc,
		stack: vm.stack.createView(argCount + 1), // "+1" is the callee, which is on the stack
	})
}

// runtimeError stops the execution and reports a runtime error with a given
// message and fmt.Printf-like arguments.
//
// TODO: Return errors Go-style instead?
func (vm *VM) runtimeError(format string, a ...interface{}) {
	fmt.Fprintf(os.Stderr, format+"\n", a...)

	stackTrace := strings.Builder{}
	for i := len(vm.frames) - 1; i >= 0; i-- {
		frame := vm.frames[i]
		proc := frame.proc
		instructionOffset := frame.ip - 1
		chunkIndex := proc.ChunkIndex
		lineNumber := vm.debugInfo.ChunksLines[chunkIndex][instructionOffset]
		functionName := vm.debugInfo.ChunksNames[chunkIndex]
		stackTrace.WriteString(fmt.Sprintf("[line %v] in %v\n", lineNumber, functionName))
	}

	stackTrace.WriteRune('\n')
	panic(errs.NewRuntime(stackTrace.String()))
}

// callFrame contains the information needed at runtime about an ongoing
// Procedure call.
type callFrame struct {
	// proc is the Procedure running.
	proc bytecode.Procedure

	// ip is the instruction pointer, which points to the next instruction to be
	// executed (it's an index into proc's chunk).
	ip int

	// stack is a read/write view into the VM stack, and represents the stack
	// that this Procedure can use.
	stack *StackView
}
